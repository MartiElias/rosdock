#!/usr/bin/env bash
set -euo pipefail
ARGC_ORIG=$#   # para saber si rosdock fue llamado con argumentos
PWD_ABS="$(pwd)"

ensure_local_config() {

  local cfg_dir="$PWD/.config/rosdock"
  local cfg_yml="$cfg_dir/config.yml"
  local ep_sh="$cfg_dir/entrypoint.sh"
  local bashfile="$cfg_dir/bashfile.txt"

  # crea carpeta si no existe
  mkdir -p "$cfg_dir"

  # decide valores a escribir en config.yml
  local image_val root_val name_val
  if (( ARGC_ORIG > 0 )); then
    # usar lo que haya quedado configurado por CLI/YAML (ya parseado)
    image_val="${IMAGE:-ros:humble}"
    root_val="${ROOT:-/work}"
    name_val="${NAME:-ros}"
  else
    # ejemplos por defecto si no hubo argumentos
    image_val="image_name"
    root_val="work_dir"
    name_val="container_name"
  fi

  # crea config.yml si no existe
  if [[ ! -f "$cfg_yml" ]]; then
    cat > "$cfg_yml" <<EOF
# Local rosdock config (auto-generated)
default_image: ${image_val}
default_root: ${root_val}
gpus: ${GPUS:-0}
env:
  LANG: C.UTF-8
  RMW_IMPLEMENTATION: rmw_fastrtps_cpp
entrypoint_path: "./.config/rosdock/entrypoint.sh"
EOF
    echo "[rosdock] created $cfg_yml"
  fi

  # crea entrypoint.sh si no existe (plantilla mínima segura)
  if [[ ! -f "$ep_sh" ]]; then
    cat > "$ep_sh" <<'EOSH'
#!/usr/bin/env bash
set -euo pipefail

cat /rosdock/bashfile.txt >> ~/.bashrc
# Ejecuta el comando recibido
exec "$@"
EOSH
    echo "[rosdock] create $ep_sh"
    chmod +x $ep_sh
  fi

  if [[ ! -f "$bashfile" ]]; then
    cat > "$bashfile" <<'EOSH'
# soruce $ROSDOCK_WS/ros2_ws/install/setup.bash
EOSH
    echo "[rosdock] create $bashfile"
  fi
}

ensure_local_config

# -----------------------------
# Defaults (pueden venir de config.yml o CLI)
# -----------------------------
IMAGE="ros:humble"
ROOT="/work"
NAME="ros"
GPUS="0"             # "1" => --gpus all
SUBCMD="run"         # run|attach
EXTRA_ENVS=()

# -----------------------------
# Helpers
# -----------------------------
die(){ echo "rosdock: $*" >&2; exit 1; }

have(){ command -v "$1" >/dev/null 2>&1; }

docker_ok(){
  have docker || die "docker no está en PATH"
  docker info >/dev/null 2>&1 || die "Docker daemon no responde"
}

usage(){
  cat <<EOF
Uso: rosdock [opciones] [--] [CMD...]        (modo por defecto = run)
     rosdock attach                           (intenta entrar a un contenedor existente)

Opciones:
  --image=IMAGEN           (def: $IMAGE)
  --root=PATH              raíz dentro del contenedor (def: $ROOT)
  --name=NOMBRE            nombre del contenedor (def: rosdock-<carpeta>-<hash>)
  --gpus                   añade --gpus all
  --env KEY=VAL            añade variable de entorno (repetible)
  --mount spec             añade --mount (repetible, formato docker --mount)
  attach                   subcomando: adjunta a contenedor existente del proyecto
  -h, --help               ayuda

Ejemplos:
  rosdock --image=ros:humble --dir='*_ws'
  rosdock --image=myimg --depth=2 --order=bottomup -- bash -lc "colcon build && bash"
  rosdock attach
EOF
}

# -----------------------------
# Cargar config YAML si hay yq
# -----------------------------
CONFIG_FILE="${XDG_CONFIG_HOME:-$PWD_ABS/.config}/rosdock/config.yml"
echo ""
echo $CONFIG_FILE
echo ""
if [[ -f "$CONFIG_FILE" ]] && have yq; then
  IMAGE="$(yq -r '.default_image // "'"$IMAGE"'"' "$CONFIG_FILE")"
  ROOT="$(yq -r '.default_root // "'"$ROOT"'"' "$CONFIG_FILE")"
  GPUS_VAL="$(yq -r '.gpus // "false"' "$CONFIG_FILE")"
  [[ "$GPUS_VAL" == "true" ]] && GPUS="1"
  # Leer variables de entorno desde config.yml (si existen)
  if yq -e '.env' "$CONFIG_FILE" >/dev/null 2>&1; then
    while IFS="=" read -r key val; do
      [[ -n "$key" && -n "$val" ]] && EXTRA_ENVS+=( -e "$key=$val" )
    done < <(yq -r '.env | to_entries[] | "\(.key)=\(.value)"' "$CONFIG_FILE")
  fi

fi

echo ""
echo $ROOT
echo ""


# -----------------------------
# Parse CLI
# -----------------------------
if [[ $# -gt 0 && "$1" == "attach" ]]; then SUBCMD="attach"; shift; fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --image=*) IMAGE="${1#*=}" ;;
    --root=*) ROOT="${1#*=}" ;;
    --name=*) NAME="${1#*=}" ;;
    --gpus) GPUS="1" ;;
    --env) shift; [[ $# -gt 0 ]] || die "--env requiere KEY=VAL"; EXTRA_ENVS+=( -e "$1" ) ;;
    --env=*) EXTRA_ENVS+=( -e "${1#*=}" ) ;;
    --mount) shift; [[ $# -gt 0 ]] || die "--mount requiere spec"; EXTRA_MOUNTS+=( --mount "$1" ) ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    *) break ;;
  esac
  shift
done

CMD=( "$@" )
[[ ${#CMD[@]} -eq 0 ]] && CMD=( /bin/bash )

docker_ok

BASE="$(basename "$PWD_ABS")"
[[ -z "$NAME" ]] && NAME="rosdock-${BASE}-${HASH}"

echo "[rosdock] image=$IMAGE  root=$ROOT  name=$NAME"

# -----------------------------
# Preparar docker run args
# -----------------------------
DOCKER_ARGS=(
  run -it --rm
  --network host
  -e DISPLAY=${DISPLAY}
  -e TERM="$TERM" 
  -e COLORTERM="${COLORTERM:-truecolor}"
  -v /tmp/.X11-unix:/tmp/.X11-unix:rw
  --name "$NAME"
  --mount "type=bind,src=$PWD_ABS,dst=$ROOT"
  -v $PWD_ABS/.config/rosdock:/rosdock
  --entrypoint /rosdock/entrypoint.sh
)

# Añadir variables de entorno extra del config.yml (idioma midelware)
DOCKER_ARGS+=( "${EXTRA_ENVS[@]}" )


# GPUs
[[ "$GPUS" == "1" ]] && DOCKER_ARGS+=( --gpus all )


# Imagen y comando
DOCKER_ARGS+=( "$IMAGE" )
DOCKER_ARGS+=( "${CMD[@]}" )

echo "${DOCKER_ARGS[@]}"

# Exec
exec docker "${DOCKER_ARGS[@]}"
